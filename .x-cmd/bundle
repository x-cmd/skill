# shellcheck shell=dash disable=2016
___X_CMD_ZUZ_QUIET=true

bundle_tmp2tgz()(
    x cd "$(x wsroot)/.tmp"
    x rmrf web_data/tmp
    # x ws onemin_data
    x z "skills.tar.gz"  * || return
    x rmrf "${output}/skills.tar.gz"
    x mkdirp "${output}"
    x mv "skills.tar.gz" "${output}/skills.tar.gz"
    x touch "${output}/skills_hash.txt"
    x hash sha512 "${output}/skills.tar.gz" > "${output}/skills_hash.txt"

    x:info "Generate skills.tar.gz file, size: $(du -h "${output}/skills.tar.gz" | awk '{print $1}')"
)

bundle_xcmd_skill_data()(
    local tgtprefix=; tgtprefix="$(x wsroot)/.tmp"
    x:info "BEGIN ==== > bundle x-cmd/skill data"

    x mkdirp "$tgtprefix"
    x cp -rf "data" "$tgtprefix/" || {
        x:error "wrong: data"
        return 1
    }
    x yq eval-all -o=tsv '[.[]
        | del(.path,.tag,.avatar,.installation)
        | (. as $item | with_entries(select(.key != "description")) + {"type": "skill"} + {"description": $item.description} )
      ]' index/skill/**/index.yml  \
    > "$tgtprefix/index.tsv" || {
        x:error "wrong: skill index"
        return 1
    }
    x yq eval-all -o=tsv '[.[]
        | del(.path,.tag,.avatar,.installation)
        | (. as $item | with_entries(select(.key != "description")) + {"type": "mcp"} + {"description": $item.description} )
      ]' index/mcp/index.yml  \
      | command tail -n +2 \
    >> "$tgtprefix/index.tsv" || {
        x:error "wrong: mcp index"
        return 1
    }

    x awk '
        BEGIN {
            print "{"
            first_item = 1
        }

        /^- id:/ {
            if (name != "") { print_block() }
            name=""; desc=""; type=""; url=""; cmd="";
            args_str=""; in_args=0;
            env_str=""; in_env=0;
        }

        /^[[:space:]]*name:/ {
            gsub(/^[[:space:]]*name:[[:space:]]*/, "")
            name = $0
        }

        /^[[:space:]]*description:/ {
            sub(/^[[:space:]]*description:[[:space:]]*/, "")
            desc = $0
        }

        /^[[:space:]]*stdio:/ { type = "stdio" }
        /^[[:space:]]*http:/ { type = "http" }

        type=="http" && /^[[:space:]]*url:/ {
            sub(/^[[:space:]]*url:[[:space:]]*/, "")
            url = $0
        }

        type=="stdio" && /^[[:space:]]*command:/ {
            sub(/^[[:space:]]*command:[[:space:]]*/, "")
            cmd = $0
        }

        type=="stdio" && /^[[:space:]]*args:/ { in_args=1; in_env=0; next }

        in_args && /^[[:space:]]*- / {
            sub(/^[[:space:]]*- /, "")
            val = $0
            gsub(/^'\''|'\''$/, "", val)
            gsub(/^"|"$/, "", val)

            if (args_str != "") args_str = args_str ", "
            args_str = args_str "\"" val "\""
        }

        type=="stdio" && /^[[:space:]]*env:/ { in_env=1; in_args=0; next }

        in_env && /:/ && !/env:/ {
            key_part = $0; sub(/:.*/, "", key_part); sub(/^[[:space:]]*/, "", key_part);
            val_part = $0; sub(/^[[:space:]]*[^:]+:[[:space:]]*/, "", val_part);

            if (env_str != "") env_str = env_str ", "
            env_str = env_str "\"" key_part "\": \"" val_part "\""
        }


        function print_block() {
            if (!first_item) print ","
            first_item = 0
            printf "  \"%s\": {\n", name

            if (type == "stdio") {
                printf "    \"stdio\": {\n"
                printf "      \"command\": \"%s\",\n", cmd
                printf "      \"args\": [%s],\n", args_str

                if (env_str != "") {
                    printf "      \"env\": { %s },\n", env_str
                }

                printf "      \"description\": \"%s\"\n", desc
                printf "    }\n"
            } else {
                printf "    \"http\": {\n"
                printf "      \"type\": \"http\",\n"
                printf "      \"url\": \"%s\",\n", url
                printf "      \"description\": \"%s\"\n", desc
                printf "    }\n"
            }
            printf "  }"
        }

        END {
            if (name != "") print_block()
            print "\n}"
        }
    ' index/mcp/index.yml > "$tgtprefix/mcp.json" || {
        x:error "wrong: mcp list"
        return 1
    }

    x:info "END ==== > bundle skill data"
)

bundle_xcmd_skill_packages(){
    local tgtprefix=; tgtprefix="$(x wsroot)/.release"
    x:info "BEGIN ==== > bundle x-cmd/skill ZIP file"

    x mkdirp "$tgtprefix"
    local skill_name; local skill_file; local skill_dir
    x find data -name "SKILL.md" -type f | while read -r skill_file;do
        skill_dir="${skill_file%/SKILL.md}"
        skill_name="${skill_dir##*/}"
        x rmrf "$tgtprefix/.tmp"
        x cp -rf "$skill_dir" "$tgtprefix/.tmp/$skill_name"
        case "$skill_dir" in
            */k-dense-ai/*)   x cp -rf "data/k-dense-ai/LICENSE.md" "$tgtprefix/.tmp/$skill_name/";;
            */superpowers)    x cp -rf "data/superpowers/LICENSE" "$tgtprefix/.tmp/$skill_name/";;
            */x-cmd/*)        x cp -rf LICENSE "$tgtprefix/.tmp/$skill_name/";;
        esac
        x z "$tgtprefix/${skill_name}.zip" "$tgtprefix/.tmp/$skill_name"
    done

    x:info "END ==== > bundle skill ZIP file"
}

bundle()(
    local x_cmd_skill_version="${___X_CMD_SKILL_RELEASE_VERSION:-"v0.0.11"}";

    local root; root="$(x wsroot)"
    local output; output="$root/dist"
    local skip_version_sh
    while [ $# -gt 0 ]; do
        case "$1" in
            --version)   shift; x_cmd_skill_version="$1";              shift ;;
            -o|--output) shift; output="$root/$1";                   shift ;;
            --skip_version_sh)  skip_version_sh="--skip_version_sh"; shift ;;
            *)           break ;;
        esac
    done

    x:info "bundle $x_cmd_skill_version to $output, skip_version_sh=$skip_version_sh"

    case "$1" in
        "") ;;
        *)
            if ! command -v "bundle_$1" >/dev/null 2>&1; then
                x:error "Unexisted bundle command: $1"
                return 1
            fi
            local op="$1"; shift;
            "bundle_$op" "$@" ; return
    esac

    x rmrf .tmp

    if ! bundle_xcmd_skill_data ; then
        x:error "bundle_xcmd_skill_data failed"
        return 1
    fi

    if ! bundle_xcmd_skill_packages ; then
        x:error "bundle_skill_zip_file failed"
        return 1
    fi

    if ! bundle_tmp2tgz ; then
        x:error "bundle_yml2tgz failed"
        return 1
    fi
)


(
    x cd "$(x wsroot)"
    bundle "$@"
) || return
